<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Vamana Semantle | Ben Landrum</title>
<link href="../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../rss.xml">
<link rel="canonical" href="https:///ben-landrum.com/vamana-semantle/">
<!--[if lt IE 9]><script src="../assets/js/html5.js"></script><![endif]--><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NNPDQP26');</script><!-- End Google Tag Manager --><script src="assets/js/global.js"></script><meta name="author" content="Ben Landrum">
<meta property="og:site_name" content="Ben Landrum">
<meta property="og:title" content="Vamana Semantle">
<meta property="og:url" content="https:///ben-landrum.com/vamana-semantle/">
<meta property="og:description" content='Semantle Game
    Start New Game
    
    Guess
    
    
    
    

    
        let targetWord = "";
        let guesses = [];
        // Cache for storing similarity data: guessDataCache[word] = { '>
<meta property="og:type" content="article">
<meta property="article:published_time" content="2025-01-29T18:22:18-05:00">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-light
bg-light
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="../">

            <span id="blog-title">Ben Landrum</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto"><li class="nav-item">
<a href="../archive.html" class="nav-link">Archive</a>

                
            </li></ul>
<ul class="navbar-nav navbar-right">
<li class="nav-item">
    <a href="index.src.html" id="sourcelink" class="nav-link">Source</a>
    </li>


                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text storypage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Vamana Semantle</a></h1>

        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <h1>Semantle Game</h1>
    <button onclick="startGame()">Start New Game</button>
    <input type="text" id="guessInput" placeholder="Enter a word"><button onclick="makeGuess()">Guess</button>
    
    <div id="neighbors"></div>
    <div id="highlightedGuesses"></div>
    <div id="guesses"></div>

    <script>
        let targetWord = "";
        let guesses = [];
        // Cache for storing similarity data: guessDataCache[word] = { similarity, rank }
        let guessDataCache = {};
        // Cache for storing neighbor lists: neighborsCache[word] = [neighbor1, neighbor2, ...]
        let neighborsCache = {};

        function saveState() {
            localStorage.setItem("targetWord", targetWord);
            localStorage.setItem("guesses", JSON.stringify(guesses));
            localStorage.setItem("guessDataCache", JSON.stringify(guessDataCache));
            localStorage.setItem("neighborsCache", JSON.stringify(neighborsCache));
        }

        function loadState() {
            targetWord = localStorage.getItem("targetWord") || "";
            guesses = JSON.parse(localStorage.getItem("guesses")) || [];
            guessDataCache = JSON.parse(localStorage.getItem("guessDataCache")) || {};
            neighborsCache = JSON.parse(localStorage.getItem("neighborsCache")) || {};
            if (!targetWord) {
                startGame();
            } else {
                renderGuesses();
            }
        }

        async function startGame() {
            let res = await fetch("https://semantle-graph.onrender.com/get_vocab");
            let data = await res.json();
            let vocab = data.vocab;
            targetWord = vocab[Math.floor(Math.random() * vocab.length)];
            guesses = [];
            guessDataCache = {};
            neighborsCache = {};
            saveState();
            document.getElementById("guesses").innerHTML = "";
            document.getElementById("highlightedGuesses").innerHTML = "";
            document.getElementById("neighbors").innerHTML = "";
            alert("New game started! A word has been chosen.");
        }

        async function makeGuess(word = null) {
            let guessWord = word || document.getElementById("guessInput").value.toLowerCase();
            if (!guessWord) return alert("Enter a word!");
            if (guesses.some(g => g.word === guessWord)) return alert("You already guessed this word!");

            // If in cache, skip re-fetch
            let similarity, rank;
            if (guessDataCache[guessWord]) {
                similarity = guessDataCache[guessWord].similarity;
                rank = guessDataCache[guessWord].rank;
            } else {
                let simRes = await fetch("https://semantle-graph.onrender.com/similarity", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ word1: targetWord, word2: guessWord })
                });
                let simData = await simRes.json();
                if (simData.error) {
                    alert(simData.error);
                    return;
                }
                similarity = simData.similarity;

                let topKRes = await fetch("https://semantle-graph.onrender.com/top_k", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ word: guessWord, k: 1000 })
                });
                let topKData = await topKRes.json();
                rank = topKData.top_words.indexOf(guessWord);

                guessDataCache[guessWord] = { similarity, rank };
            }

            guesses.push({ word: guessWord, similarity, rank });
            guesses.sort((a, b) => b.similarity - a.similarity);
            saveState();
            renderGuesses();
            refreshNeighborColors();

            if (guessWord === targetWord) alert(`ðŸŽ‰ You guessed the word! It was "${targetWord}"`);

            // Prefetch neighbors in the background (for faster future display)
            prefetchNeighbors(guessWord);
        }

        function renderGuesses() {
            let topGuesses = guesses.filter(g => g.rank > 0 && g.rank <= 1000);
            let otherGuesses = guesses.filter(g => g.rank === 0 || g.rank > 1000);
            
            let highlightedGuesses = topGuesses.length > 0
                ? `<div class="highlight-container">` +
                  topGuesses.map((g, i) =>
                    `<div class="guess" onclick="fetchNeighbors('${g.word}')">${i + 1}. <b>${g.word}</b> - Similarity: ${g.similarity.toFixed(4)} (Rank: ${g.rank})</div>`
                  ).join("") +
                  `</div>`
                : "";

            let otherGuessesHtml = otherGuesses.map((g, i) =>
                `<div class="guess" onclick="fetchNeighbors('${g.word}')">${i + 1 + topGuesses.length}. <b>${g.word}</b> - Similarity: ${g.similarity.toFixed(4)}</div>`
            ).join("");
            
            document.getElementById("highlightedGuesses").innerHTML = highlightedGuesses;
            document.getElementById("guesses").innerHTML = otherGuessesHtml;
        }

        // Fetch neighbors in the background, store them in neighborsCache
        async function prefetchNeighbors(word) {
            // If we already have neighbors for this word, skip
            if (neighborsCache[word]) return;
            try {
                let res = await fetch("https://semantle-graph.onrender.com/neighbors", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ word })
                });
                let data = await res.json();
                if (!data.error) {
                    neighborsCache[word] = data.neighbors;
                    saveState();
                }
            } catch (e) {
                // ignore
            }
        }

        // Show neighbors in UI, then prefetch their similarities
        async function fetchNeighbors(word) {
            // If neighbors already cached, render immediately
            if (neighborsCache[word]) {
                renderNeighbors(word, neighborsCache[word]);
                // Prefetch similarities in background
                prefetchNeighborSimilarities(neighborsCache[word]);
            } else {
                // Otherwise, fetch fresh neighbors, show them, then prefetch similarities
                try {
                    let res = await fetch("https://semantle-graph.onrender.com/neighbors", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ word })
                    });
                    let data = await res.json();
                    if (data.error) {
                        alert(data.error);
                        return;
                    }
                    neighborsCache[word] = data.neighbors;
                    renderNeighbors(word, data.neighbors);
                    saveState();
                    prefetchNeighborSimilarities(data.neighbors);
                } catch (e) {
                    alert("Error fetching neighbors: " + e);
                }
            }
        }

        function renderNeighbors(word, neighborList) {
            // Render immediately
            document.getElementById("neighbors").innerHTML =
                `<div class="neighbors">Neighbors of <b>${word}</b>: ` +
                neighborList.map(n => `<span class="neighbor" id="neighbor-${n}" onclick="makeGuess('${n}')">${n}</span>`).join(" ") +
                `</div>`;
            refreshNeighborColors();
        }

        // Prefetch similarity info for each neighbor in the background
        async function prefetchNeighborSimilarities(neighborList) {
            for (let n of neighborList) {
                if (!guessDataCache[n]) {
                    // Fire off requests in parallel, no need to await each before the next
                    (async () => {
                        try {
                            let simRes = await fetch("https://semantle-graph.onrender.com/similarity", {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({ word1: targetWord, word2: n })
                            });
                            let simData = await simRes.json();
                            if (simData.error) return;

                            let topKRes = await fetch("https://semantle-graph.onrender.com/top_k", {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({ word: n, k: 1000 })
                            });
                            let topKData = await topKRes.json();
                            let rank = topKData.top_words.indexOf(n);

                            guessDataCache[n] = { similarity: simData.similarity, rank };
                            saveState();
                        } catch (e) {
                            // swallow
                        }
                    })();
                }
            }
        }

        function refreshNeighborColors() {
            document.querySelectorAll(".neighbor").forEach(neighbor => {
                let w = neighbor.textContent;
                neighbor.className = "neighbor " + (guesses.some(g => g.word === w) ? "guessed" : "not-guessed");
            });
        }

        document.getElementById("guessInput").addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                event.preventDefault();
                makeGuess();
            }
        });

        loadState();
    </script>
</div>
    

</article><!--End of body content--><footer id="footer">
            Contents Â© 2025         <a href="mailto:8enlandrum@gmail.com">Ben Landrum</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script><!-- Google Tag Manager (noscript) --><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NNPDQP26" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

</body>
</html>
